# simple-load-balancer

# Project Goal and System Design

The primary goal is to design and implement a functional load balancer with Python that embodies core distributed systems concepts and supports the following features:

1. L7 Load Balancer: support HTTP protocol
2. Support Multiple Services: provide APIs (using Flask) for service registration, and route traffic based on the Host header from client requests
3. Service Discovery: use a service registry (backed by mongodb) to keep track of server instances of different services
4. Different Load Balancing Algorithms: implement static (round robin, IP hash) and dynamic (least connection) load balancing algorithms
5. Sticky Sessions: an option to ensure that requests from the same client are directed to the same server to maintain session state
6. Health Check and Failover: reroute traffic in case of server failure
7. Optional: Logging & Monitoring (Prometheus & Grafana)
8. One single configuration file for the project
9. Simple, one-file client (load-generator) and HTTP server (duplicated instances) for demoing the load balancer, config of these use a hard-coded variable instead of config file for simplicity

# Service Registry

Load balancer provides Service Registry Restful APIs via Flask to manage services and their instances.

APIs are served on a dedicated port

## Service Management

call this api to manage the services

- id (unique, auto generated by db)
- service name (unique)
- service header (unique)
- algorithm (round robin, ip hash, least connection)
- statefulness (if true â†’ sticky session)

## Instance Management

when a new service instance is created/deleted, call this api to update the instance list

- id (auto generated by db)
- service id
- addr (unique, could be ip:port or domain name)
- status (or we can just delete the entry)

